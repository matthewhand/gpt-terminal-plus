// Function: executeCommand
async executeCommand(command: string, options: { timeout?: number, directory?: string, linesPerPage?: number } = {}): Promise<{ stdout?: string, stderr?: string, pages?: string[], totalPages?: number, responseId?: string }> {
  const { timeout = 5000, directory = '', linesPerPage = 100 } = options;
  const execOptions = {
      timeout,
      cwd: directory || process.cwd(),
      shell: this.serverConfig.shell ? this.serverConfig.shell.toString() : undefined
  };

  try {
      const { stdout, stderr } = await this.execAsync(command, execOptions);

      if (linesPerPage > 0) {
          const output = stdout + (stderr ? `\nErrors:\n${stderr}` : '');
          const lines = output.split('\n');
          const pages = [];
          for (let i = 0; i < lines.length; i += linesPerPage) {
              pages.push(lines.slice(i, i + linesPerPage).join('\n'));
          }
          return {
              stdout,
              stderr,
              pages,
              totalPages: pages.length,
              responseId: this.generateResponseId()
          };
      }

      return { stdout, stderr };
  } catch (error) {
      console.error('Error executing command:', error);
      throw new Error('Failed to execute command');
  }
}

// Function: listFiles
async listFiles(directory: string, limit = 42, offset = 0, orderBy = 'filename'): Promise<{ items: string[]; totalPages: number; responseId: string }> {
  try {
      const fullPaths = await fs.promises.readdir(directory, { withFileTypes: true });
      let fileNames = fullPaths.filter(dirent => dirent.isFile()).map(dirent => dirent.name);

      if (orderBy === 'datetime') {
          const filesWithStats = await Promise.all(fileNames.map(async fileName => {
              const fullPath = path.join(directory, fileName);
              const stats = await fs.promises.stat(fullPath);
              return { name: fileName, mtime: stats.mtime };
          }));

          fileNames = filesWithStats.sort((a, b) => b.mtime.getTime() - a.mtime.getTime()).map(file => file.name);
      } else {
          fileNames.sort();
      }

      const totalPages = Math.ceil(fileNames.length / limit);
      const paginatedFiles = fileNames.slice(offset, offset + limit);

      return {
          items: paginatedFiles,
          totalPages,
          responseId: this.generateResponseId()
      };
  } catch (error) {
      throw error;
  }
}

// Function: createFile
async createFile(directory: string, filename: string, content: string, backup: boolean): Promise<boolean> {
  const filePath = path.join(directory, filename);
  try {
      if (backup && fs.existsSync(filePath)) {
          const backupPath = filePath + '.bak';
          fs.copyFileSync(filePath, backupPath);
      }

      fs.writeFileSync(filePath, content);
      return true;
  } catch (error) {
      return false;
  }
}
