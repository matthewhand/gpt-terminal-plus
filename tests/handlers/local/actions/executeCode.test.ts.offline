import { spawn } from 'child_process';
import * as fs from 'fs';
import LocalServer from '../../../../src/handlers/local/LocalServerHandler';
import { ExecutionResult } from '../../../../src/types/ExecutionResult';

// Mocking spawn and fs modules
jest.mock('child_process', () => ({
    spawn: jest.fn(),
}));

jest.mock('fs', () => ({
    promises: {
        writeFile: jest.fn(),
        unlink: jest.fn(),
    },
}));

describe('LocalServer - executeCode', () => {
    let localServer: LocalServer;

    beforeEach(() => {
        localServer = new LocalServer({
            protocol: 'local',
            hostname: 'localhost',
            code: true,
            // supportedLanguages: ['typescript', 'python'],
        });
    });

    afterEach(() => {
        jest.clearAllMocks();
        delete process.env.ENABLE_CLEANUP; // Reset to default behavior after each test
    });

    it('should execute a Python script correctly', async () => {
        const mockSpawn = spawn as jest.Mock;
        const mockStdout = 'Python script output';
        const mockProcess = {
            stdout: {
                on: jest.fn().mockImplementation((event, callback) => {
                    if (event === 'data') callback(Buffer.from(mockStdout));
                }),
            },
            stderr: {
                on: jest.fn().mockImplementation(() => {}),
            },
            on: jest.fn().mockImplementation((event, callback) => {
                if (event === 'close') callback(0);
            }),
        };
        mockSpawn.mockReturnValue(mockProcess);

        const result: ExecutionResult = await localServer.executeCode("print('Hello, Python!')", 'python');

        expect(fs.promises.writeFile).toHaveBeenCalledWith(expect.any(String), expect.any(String), { mode: 0o755 });
        expect(spawn).toHaveBeenCalledWith('python3', [expect.any(String)], expect.any(Object));
        expect(result.stdout).toBe(mockStdout);
        expect(result.error).toBe(false);
    });

    it('should execute a TypeScript script correctly', async () => {
        const mockSpawn = spawn as jest.Mock;
        const mockStdout = 'TypeScript output';
        const mockProcess = {
            stdout: {
                on: jest.fn().mockImplementation((event, callback) => {
                    if (event === 'data') callback(Buffer.from(mockStdout));
                }),
            },
            stderr: {
                on: jest.fn().mockImplementation(() => {}),
            },
            on: jest.fn().mockImplementation((event, callback) => {
                if (event === 'close') callback(0);
            }),
        };
        mockSpawn.mockReturnValue(mockProcess);

        const result: ExecutionResult = await localServer.executeCode("console.log('Hello, TypeScript!')", 'typescript');

        expect(fs.promises.writeFile).toHaveBeenCalledWith(expect.any(String), expect.any(String), { mode: 0o755 });
        expect(spawn).toHaveBeenCalledWith('ts-node', [expect.any(String)], expect.any(Object));
        expect(result.stdout).toBe(mockStdout);
        expect(result.error).toBe(false);
    });

    it('should handle execution errors without cleanup', async () => {
        process.env.ENABLE_CLEANUP = 'false';

        const mockSpawn = spawn as jest.Mock;
        const mockStderr = 'Error output';
        const mockProcess = {
            stdout: { on: jest.fn() },
            stderr: {
                on: jest.fn().mockImplementation((event, callback) => {
                    if (event === 'data') callback(Buffer.from(mockStderr));
                }),
            },
            on: jest.fn().mockImplementation((event, callback) => {
                if (event === 'close') callback(1);
            }),
        };
        mockSpawn.mockReturnValue(mockProcess);

        await expect(localServer.executeCode("print('This will fail')", 'python')).rejects.toThrow('Command failed with exit code 1');

        expect(fs.promises.unlink).not.toHaveBeenCalled();
    });

    it('should handle execution errors with cleanup enabled via env var', async () => {
        process.env.ENABLE_CLEANUP = 'true';

        const mockSpawn = spawn as jest.Mock;
        const mockStderr = 'Error output';
        const mockProcess = {
            stdout: { on: jest.fn() },
            stderr: {
                on: jest.fn().mockImplementation((event, callback) => {
                    if (event === 'data') callback(Buffer.from(mockStderr));
                }),
            },
            on: jest.fn().mockImplementation((event, callback) => {
                if (event === 'close') callback(1);
            }),
        };
        mockSpawn.mockReturnValue(mockProcess);

        await expect(localServer.executeCode("print('This will fail')", 'python')).rejects.toThrow('Command failed with exit code 1');

        expect(fs.promises.unlink).toHaveBeenCalled();
    });
});
