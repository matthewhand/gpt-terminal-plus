import { execFile } from 'child_process';
import * as fs from 'fs';
import { executeCode } from '../../../../src/handlers/local/actions/executeCode';
import { SupportedLanguages } from '../../../../src/types/SupportedLanguages';

// Mocking execFile and fs modules
jest.mock('child_process', () => ({
    execFile: jest.fn(),
}));

jest.mock('fs', () => ({
    promises: {
        writeFile: jest.fn(),
        unlink: jest.fn(),
    },
}));

describe('executeCode', () => {
    afterEach(() => {
        jest.clearAllMocks();
        delete process.env.ENABLE_CLEANUP; // Reset to default behavior after each test
    });

    test('should execute a Python script correctly', async () => {
        (execFile as unknown as jest.Mock).mockImplementation((command, args, options, callback) => {
            callback(null, 'Python script output', '');
        });

        const result = await executeCode("print('Hello, Python!')", 'python');

        expect(fs.promises.writeFile).toHaveBeenCalledWith(expect.any(String), expect.any(String), { mode: 0o755 });
        expect(execFile).toHaveBeenCalledWith(expect.stringContaining('python3'), [], expect.any(Object), expect.any(Function));
        expect(result.stdout).toBe('Python script output');
        expect(result.error).toBe(false);
    });

    test('should execute a TypeScript script correctly', async () => {
        (execFile as unknown as jest.Mock).mockImplementation((command, args, options, callback) => {
            callback(null, 'TypeScript output', '');
        });

        const result = await executeCode("console.log('Hello, TypeScript!')", 'typescript');

        expect(fs.promises.writeFile).toHaveBeenCalledWith(expect.any(String), expect.any(String), { mode: 0o755 });
        expect(execFile).toHaveBeenCalledWith(expect.stringContaining('tsc'), [], expect.any(Object), expect.any(Function));
        expect(result.stdout).toBe('TypeScript output');
        expect(result.error).toBe(false);
    });

    test('should handle execution errors without cleanup', async () => {
        process.env.ENABLE_CLEANUP = 'false';

        (execFile as unknown as jest.Mock).mockImplementation((command, args, options, callback) => {
            callback(new Error('Execution failed'), '', 'Error output');
        });

        await expect(executeCode("print('This will fail')", 'python')).rejects.toThrow('Execution failed');

        // Ensure cleanup was not called
        expect(fs.promises.unlink).not.toHaveBeenCalled();
    });

    test('should handle execution errors with cleanup enabled via env var', async () => {
        process.env.ENABLE_CLEANUP = 'true';

        (execFile as unknown as jest.Mock).mockImplementation((command, args, options, callback) => {
            callback(new Error('Execution failed'), '', 'Error output');
        });

        await expect(executeCode("print('This will fail')", 'python')).rejects.toThrow('Execution failed');

        // Ensure cleanup was called
        expect(fs.promises.unlink).toHaveBeenCalled();
    });
});
